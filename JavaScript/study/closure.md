# Closure
외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 **클로저**라고 부른다.

클로저는 자바스크립트 고유의 개념이 아닌 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.

```jsx
const x = 1;

function outer() {
	const x = 10;
	const inner = function() {
		console.log(x);
	};
	return inner;
}

const innerFunc = outer();
innerFunc(); // 10
```

## 클로저의 활용

상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다.

### 예제

```jsx
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function() {
	// 카운트 상태를 1만큼 증가시킨다.
	return ++num;
}

console.log(increase()); // 1 
console.log(increase()); // 2 
console.log(increase()); // 3 
```

위 코드는 잘 동작하지만 오류를 발생시킬 가능성을 내포하고 있다.

그 이유는 위 예제가 바르에 동작하려면 다음의 전제 조건이 지켜져야 하기 때문이다.

1. 카운트 상태(변수 num의 값)는 increase 함수가 호출되기 전까지 변경되지 않고 유지되어야 한다.
2. 이를 위해 카운트 상태(변수 num의 값)는 increase 함수만이 변경할 수 있어야 한다.

하지만 카운트 상태는 전역 변수를 통해 관리되고 있기 때문에 언제든지 누구나 접근할 수 있고 변경할 수 있다.

```jsx
// 카운트 상태 변경 함수
const increase = (function() {
	// 카운트 상태 변수
	let num = 0;

	// 클로저
	return function() {
		// 카운트 상태를 1만큼 증가시킨다.
		return ++num;	
	}
}());
console.log(increase()); // 1 
console.log(increase()); // 2 
console.log(increase()); // 3 
```

위 코드가 실행되면 즉시 실행 함수가 호출되고 즉시 실행 함수가 반환한 함수가 increase 변수에 할당된다.

increase 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저다.

즉시 실행 함수는 호출된 이후 소멸되지만 즉시 실행 함수가 반환한 클로저는 increase 변수에 할당되어 호출된다. 이때 즉시 실행 함수가 반환한 클로저는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하고 있다. 따라서 즉시 실행 항수가 반환한 클로저는 카운트 상태를 유지하기 위한 자유 변수 num을 언제 어디서 호출하든지 참조하고 변경할 수 있다.